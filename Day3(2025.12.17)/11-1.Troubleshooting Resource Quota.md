# Chapter 6. Enable Developer Self-Service


## 6-1. Project and Cluster Quotas

쿠버네티스는 앞으로 노드를 얼마나 더 추가할지 알 수 없기 때문에, 설정한 Quota 값이 물리적으로 가능한지 검사하지 않고 설정해버린다.  
예를 들어, 가능한 물리 서버 전체 메모리가 10GiB밖에 안 되는데, ResourceQuota는 100GiB로 설정한다면  
서버 전체 자원보다 Quota가 크기 때문에, 쿠버네티스가 설정을 거부할 것 같지만 그대로 설정되어버린다.  


### Troubleshooting Resource Quotas

잘못된 resourcequota 설정을 하는 경우를 예로 들어보자.
배포 수를 제한하는 올바른 구문은 count/deployments.apps이다.

그런데 "oc create resourcequota example --hard=count/deployment=1"와 같이 잘못된 문법으로 설정해도 resourcequota는 만들어지는 것을 알 수 있다.

object count quota가 제대로 설정되면 아래와 같이 확인되어야 한다.

```code
[user@host ~]$ oc get resourcequota
NAME      AGE   REQUEST                       LIMIT
example   4s    count/deployments.apps: 1/1
```

하지만 잘못 설정되었기 때문에

```code
[user@host ~]$ oc get resourcequota
NAME      AGE     REQUEST                 LIMIT
example   2m47s   count/deployment: 0/1
```

위와같이 0/1으로 설정이 제대로 되지 않은 것을 볼 수있다.

겉으로 보기에는 deployment가 생성된 것 처럼 보이지만 pod가 안 만들어지기 때문에  
deployment는 계속 Pending / Available 안 된다.  

왜냐하면, Deployment 객체 자체는 quota 대상이 아니기 때문이다.
Deployment → ReplicaSet → Pod로 만들어지는 과정에서 resourcequota의 영향으로 pod가 생성되지 않는다. 


이를 해결하기 위해서는

1) Deployment가 생성한 ReplicaSet의 이름을 찾은 뒤

```code
oc get rs
```

2) 해당 ReplicaSet의 상세 정보를 확인한다.

```code
oc describe rs <레플리카셋_이름>
```
설정이 잘못된 경우에는

"Events" 섹션에 다음과 같은 에러 메시지가 찍혀 있기 때문에 확인하고 resourcequota를 다시 설정해야한다.

```code
failed to create pods: pods "my-app-xyz" is forbidden: exceeded quota: example, requested: limits.memory=1Gi, used: limits.memory=0, limited: limits.memory=0
```

### 시험에 자주 나오는 부분


**1) Quota를 설정했는데 제한이 안 걸리고 파드가 계속 만들어지는 상황은 대부분 resource 이름이 틀렸을 수 있음.**

```code
oc api-resources 로 리소스 명 확인.
```
해당 명령어는 **정확한 전체 이름(NAME)**, 짧은 이름(SHORTNAMES), API 그룹을 확인가능.  

Quota의 hard 항목에 적는 이름은 반드시 api-resources 리스트에 있는 정확한 명칭이어야 한다.  
혹시라도 services 대신 service라고 쓰면 작동을 안한다.  


**2) Deployment 생성됐는데 Pod 없음**

Deployment는 Success인데 파드가 안보일 때, oc logs를 봐도 로그가 나올 파드 자체가 없어서 아무것도 확인할 수 없다. 
이는 quota를 초과해서 pod를 생성했기 때문이다.  
pod를 생성하라고 명령을 내리는 주체는 ReplicaSet이기 때문에, quota에 막혀서 생성이 거절되면 그 거절 메시지는 **ReplicaSet**의 이벤트에 남는다.  

즉, deployment는 success일 때 pod가 생성되지 않는다면 replicaset의 event를 보면된다.  

```code
1. oc get pod -> 파드 없음 확인.  

2. oc get rs -> Deployment가 생성한 ReplicaSet의 DESIRED 숫자는 1인데 CURRENT가 0인 것 확인.  

3. oc describe rs <이름> 또는 oc get events -n <네임스페이스> 확인.  
``` 


**3) quota 초과시 자주 나오는 에러 메시지**


할당량을 초과하면 즉시 오류가 발생하는 경우가 많다.  

우선 compute resource 초과 에러메세지는 아래와 같다  

```code
oc run hello --image=nginx --requests='cpu=500m'  
error: failed to create deployment: deployments.apps "hello" is forbidden:  
exceeded quota: example, requested: requests.cpu=500m, used: requests.cpu=3.8,  
limited: requests.cpu=4  
``` 

| 키워드       | 의미             | 시험에서의 해석                              |
| --------- | -------------- | ------------------------------------- |
| requested: cpu=500m | 이번에 신청한 양 | 지금 이 파드가 **500m(0.5)의 CPU를 더 쓰려고 시도함**     |
| used: cpu=3.8 | 이미 쓰고 있는 양 | 이미 이 네임스페이스에서 **3.8을 점유 중임**          |
| limited: cpu=4 | 설정된 한도 (Quota) | 최대 한도가 **4인데, 3.8 + 0.5 = 4.3**이 되어버림 |

requested: cpu=500m, used: cpu=3.8, limited: cpu=4 라면,   
Used + Requested > Limited 이기 때문에 거절된 상황인 것을 알 수 있다.  


시험 문제에서 자원을 더 늘리라는 요구가 없다면, 대부분 파드의 resources.requests/limits를 너무 크게 잡은 것이  원인이기 때문에 파드 YAML의 수치를 줄이는 것이 좋다.  

또, object count 초과시에는 아래와 같은 에러메세지를 확인할 수있다.  

```code
# Deployment 개수 제한 에러 예시
error: failed to create deployment: deployments.apps "hello" is forbidden: 
exceeded quota: example, requested: count/deployments.apps=1, used: count/deployments.apps=1, limited: count/deployments.apps=1
```

ResourceQuota는 설정하는 그 순간 이후부터 새로 생기는 파드에만 영향을 준다.  
이미 돌아가고 있는 파드들은 쿼터를 초과했더라도 강제로 죽지 않는다.  
이를 Soft Enforcement라고 하고, 다시 배포하려고 하면 그때부터는 quota초과로 배포가 되지않는다.  

